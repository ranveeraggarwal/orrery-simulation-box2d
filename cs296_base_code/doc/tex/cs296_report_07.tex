% LaTeX file for a 1 page document
\documentclass[12pt]{report}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{physymb}
\usepackage{graphicx}
%\usepackage{wrapfig}
\bibliographystyle{plain}
\usepackage{tikz}
\usepackage{natbib}
\usetikzlibrary{calc,patterns,decorations.pathmorphing,decorations.markings}

\title{Simulation of an Orrery in Box2D\\ A CS296 Report by Group 07}
\author{Ranveer Aggarwal (120050020) \\ ranveeraggarwal@gmail.com \and Devdeep Ray (120050007) \\ devdeep.ray1994@iitb.ac.in \and Sasibhushan Rallabandi (120050056) \\ sasiralla@iitb.ac.in}
\date{}

\begin{document}
\maketitle

\chapter*{Introduction}
An orrery is a mechanical model of the solar system device that illustrates the relative sizes, positions, and motions of the planets and moons according to the heliocentric model.
\\
\\
\includegraphics[scale=1]{./img/orrery-main.jpg}
\\
Though the Greeks had working planetaria, the first orrery that was a planetarium of the modern era was produced in 1704, and one was presented to the Earl of Orrery â€” whence came the name. They are typically driven by a clockwork mechanism with a globe representing the Sun at the centre, and with a planet at the end of each of the arms.


\pagebreak

\chapter*{The Idea}
\section*{Initial Design}
Our intial design that we made in Inkscape looked somewhat like this:
\\ \\
\includegraphics[scale=0.1]{./img/svg.png}
\\
Here, one of the gears in the center (say gear A) was driving one of the planets and another gear attached to it (say gear B). On top of gear B, another gear (gear C) was welded which in turn drove another gear with the same center as gear A. The angular velocity of this gear wasn't the same as A. This gear drove another planet. In this way, changing the angular velocities as a function of gear radii, we could simulate a part of the solar system. FOr the moon, we carried forward the gear motion from the center through a series of gears and attached a rod with a sphere, with a gear with the same center as the earth.

The system simulated through this arrangement assumed perfectly circular orbits, i.e. we neglected that the actual celestial orbits are a bit elliptical. Also, since the scope for error in calculations in Box2D is quite high, the system simulated by us doesn't take the exact ratios of orbits. Relatively, we tried to simulate the solar system as it is. For example the Earth revolves slower than Venus and Jupiter slower than the Earth. This has been incorporated in our design.

\pagebreak
\section*{Deviation from the Original Design}
During the course of doing this project, we learnt a lot more than what we knew initially. Hence, we continuously modified our design to reach to the final output, that looks like this:
\\ \\
\includegraphics[scale=0.25]{./img/gui.png}
\\
Basically, the concept is the same. The only difference being, to prevent cluttering, we modified the conveyor-gear (the gears that transfer motion) positions. 

Now, we have a ceantral stack which has all the planet driving gears along with the main driver gear, all of these being disjoint. Motion from the main driver gear is transferred to the subsequent gears through a series of gears on the sides of the stack as seen from the figure. One of the gears in the stack is actually the moon driver gear whose motion is transferred to the moon body through a series of gears.

The mathematics used here is basic geometry and trigonometry to calculate the gear positions and the gear radii so that consistency is maintained.

\pagebreak
\chapter*{Points of Interest}
Simulating a natural phenomenon via a mechanical simulation is in fact pretty intersting. Whereas the actual solar system works on gravitational pull between celestial bodies, this system is purely contact driven. 

While on first look it looks pretty elementary -- one could have a series of motors attached to rods to rotate the bodies as needed, but here, what we have done is, we have controlled the whole system through just one motor, i.e., changing one small motor parameter influences the whole system.

This has been done by calculating ratios of gear radii and also, the number of gears from the driver gear to the body.

Again, to make things simpler, one could have just used gear joints to connect circles and run the whole system smoothly without any sort of complication. But, we chose to make our own gear and instead of using gear joints, we relied on contact forces like friction to drive our system.

Here is how our gear looks like:
\\ \\
\includegraphics[scale=0.4]{./img/gear.png}
\\
As you can see, we have a circle and on it, a series of polygons (pentagons, can be made into sqares by uncommenting a part) that collide with each other to transfer motion. Since the pivot of the gear gives no anti-torque (frictionless), we guarantee that the gears do not stop. 

Our early design had triangles as teeth. That didn't work out as the teeth kept slipping off -- the design wasn't robust. Then we switched over to squares. It had a completely opposite problem -- the teeth stuck to each other when their sides touch. So, we combined both of these and came up with the pentagon which worked pretty well.
\pagebreak
\chapter*{Code Analysis}
\section*{Analysis with gprof Using a Callgraph}
Here's the callgraph we got running the debug profile:
\\ \\
\includegraphics[scale=0.15]{./img/callgraph.png}
\\
As we can see, the b2Min and b2Max functions take up a lot of time. Both combined, took up nearly 30\% of the whole time. Hence these need to be highly optimised. On closer inspection, we see that the children function calls by these functions is significantly higher than their own self-times. That means that maybe, the number of calls can be reduced by applying a more optimal algorithm. 

Apart from these functions, we see that the operations (subtraction, multiplication etc.) take up significant time. This can imply two things. One, the operation itself takes quite a lot of time which is probable, but less likely. Second, the number of calculations taking place is too high. This is more likely since the simulation we're running is pretty heavy on the number of calculations. Another function that takes up a lot of time is the b2PolygonShape::ComputeAABB. A similar reason as above can be given for this.

Our initial design had significantly higher number of objects than the current design. Hence, there, the time taken was more. So, when we minimised the number of gears and made the stack structure, we optimised our code. 

Further optimisation could have been possible if we would have used gear joints instead of manufacturing them ourselves, but that would have not looked as good as the current design. The current design is more consistent, robust and full of abstractions.




\bibliography{report}

\end{document}
}
